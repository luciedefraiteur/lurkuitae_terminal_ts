import * as fs from 'fs/promises';
import * as path from 'path';
import {OllamaInterface} from './ollama_interface.js';
import {RituelContext} from './types.js';

const DEFAULT_MEMORY_ROOT = path.resolve(process.cwd(), 'core', 'm√©moire_rituelle');

/**
 * Explores a branch of the memory tree.
 * @param branchPath The path to the branch to explore, relative to the memory root.
 * @param memoryRoot The root directory of the memory tree.
 * @returns A list of branches (directories) and leaves (files).
 */
export async function exploreBranch(branchPath: string = '', memoryRoot: string = DEFAULT_MEMORY_ROOT): Promise<{branches: string[], leaves: string[]}>
{
    const fullPath = path.join(memoryRoot, branchPath);
    const entries = await fs.readdir(fullPath, {withFileTypes: true});

    const branches = entries.filter(e => e.isDirectory()).map(e => e.name);
    const leaves = entries.filter(e => e.isFile()).map(e => e.name);

    return {branches, leaves};
}

/**
 * Creates a new branch in the memory tree.
 * @param branchPath The path where the new branch should be created, relative to the memory root.
 * @param poeticName The poetic name for the new branch.
 * @param memoryRoot The root directory of the memory tree.
 */
export async function createBranch(branchPath: string, poeticName: string, memoryRoot: string = DEFAULT_MEMORY_ROOT): Promise<void>
{
    const fullPath = path.join(memoryRoot, branchPath, poeticName);
    await fs.mkdir(fullPath, {recursive: true});
}

/**
 * Creates a new leaf (memory fragment) in a branch.
 * @param branchPath The path to the branch where the leaf should be created, relative to the memory root.
 * @param poeticName The poetic name for the new leaf.
 * @param content The content of the memory fragment.
 * @param memoryRoot The root directory of the memory tree.
 */
export async function createLeaf(branchPath: string, poeticName: string, content: string, memoryRoot: string = DEFAULT_MEMORY_ROOT): Promise<void>
{
    const fullPath = path.join(memoryRoot, branchPath, `${ poeticName }.md`);
    await fs.writeFile(fullPath, content, 'utf8');
}

/**
 * Reads the content of a leaf (memory fragment).
 * @param leafPath The path to the leaf to read, relative to the memory root.
 * @param memoryRoot The root directory of the memory tree.
 * @returns The content of the memory fragment.
 */
export async function readLeaf(leafPath: string, memoryRoot: string = DEFAULT_MEMORY_ROOT): Promise<string>
{
    const fullPath = path.join(memoryRoot, leafPath);
    return await fs.readFile(fullPath, 'utf8');
}

/**
 * Generates a poetic summary of an event and saves it as a new leaf.
 * @param context The current ritual context.
 * @param lastResult The result of the last executed step.
 * @param branchPath The path where the new memory should be stored.
 * @param memoryRoot The root directory of the memory tree.
 */
export async function generateAndSaveMemoryFragment(context: RituelContext, lastResult: any, branchPath: string, memoryRoot: string = DEFAULT_MEMORY_ROOT): Promise<void>
{
    // This prompt would be more sophisticated in a real implementation.
    const prompt = `Summarize the following event in a poetic and evocative way.
Event: ${ JSON.stringify(lastResult) }
Context: ${ JSON.stringify(context.narrativeState) }
`;
    const poeticSummary = await OllamaInterface.query(prompt);

    // The name would also be generated by the LLM in a full implementation.
    const poeticName = `memory-${ Date.now() }`;

    await createLeaf(branchPath, poeticName, poeticSummary, memoryRoot);
}